# src/validation/validate_schemas.py

import os
import json
import yaml
import logging
from jsonschema import validate, ValidationError
from src.utils.file_operations import load_json_file, load_yaml

def validate_json_against_schema(json_data, schema):
    """
    Validate JSON data against a JSON schema.

    Parameters:
    json_data (dict): The JSON data to validate.
    schema (dict): The JSON schema to validate against.

    Raises:
    ValidationError: If the JSON data does not conform to the schema.
    """
    try:
        validate(instance=json_data, schema=schema)
        logging.info("JSON data is valid against the schema.")
    except ValidationError as e:
        logging.error(f"JSON data is not valid against the schema: {e}")
        raise

def validate_schemas(json_schema_path, yaml_schema_path):
    """
    Validate that JSON and YAML schemas are consistent.

    Parameters:
    json_schema_path (str): Path to the JSON schema file.
    yaml_schema_path (str): Path to the YAML schema file.

    Raises:
    AssertionError: If the JSON and YAML schemas do not match.
    """
    json_schema = load_json_file(json_schema_path)
    yaml_schema = load_yaml(yaml_schema_path)

    # Log the schemas for debugging
    logging.debug(f"JSON Schema: {json.dumps(json_schema, indent=4)}")
    logging.debug(f"YAML Schema: {json.dumps(yaml_schema, indent=4)}")
    
    assert json_schema == yaml_schema, "JSON and YAML schemas do not match."
    logging.info("JSON and YAML schemas are consistent.")

def validate_subschema(sub_schema_path, full_schema_path, attribute_path):
    """
    Validate that the sub-schema is consistent with the corresponding section of the full schema.

    Parameters:
    sub_schema_path (str): Path to the sub-schema JSON file.
    full_schema_path (str): Path to the full schema JSON file.
    attribute_path (str): Dot-separated path to the attribute in the full schema to compare with the sub-schema.
    """
    sub_schema = load_json_file(sub_schema_path)
    full_schema = load_json_file(full_schema_path)
    
    # Traverse the full schema to find the corresponding attribute
    attribute_parts = attribute_path.split('.')
    full_schema_section = full_schema
    for part in attribute_parts:
        logging.debug(f"Current part: {part}")
        logging.debug(f"Current schema section: {full_schema_section}")
        if part in full_schema_section:
            full_schema_section = full_schema_section[part]
        elif 'properties' in full_schema_section and part in full_schema_section['properties']:
            full_schema_section = full_schema_section['properties'][part]
        else:
            logging.error(f"'properties' not found in the current schema section: {full_schema_section.keys()}")
            raise KeyError(f"'properties' not found in the current schema section: {full_schema_section.keys()}")

    assert sub_schema == full_schema_section, "Sub-schema does not match the corresponding section in the full schema."
    logging.info("Sub-schema is consistent with the full schema.")


if __name__ == "__main__":
    from src.config_loader import load_paths

    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
    project_root = find_project_root()
    os.chdir(project_root)
    
    paths = load_paths('config/paths.yaml')

    json_schema_path = paths['config']['schemas']['feature_metadata_complete_schema_json']
    yaml_schema_path = paths['config']['schemas']['feature_metadata_complete_schema_yaml']
    sub_schema_path = paths['config']['schemas']['missing_values_schema']
    
    validate_schemas(json_schema_path, yaml_schema_path)
    validate_subschema(sub_schema_path, json_schema_path, 'metadata_schema.properties.default_attributes.properties.missing_values')

# src/feature_engineering/update_metadata.py

import yaml
import pandas as pd
from src.config_loader import load_paths
from src.data.data_analysis import infer_data_types

def load_feature_metadata():
    paths = load_paths()
    with open(paths['config']['feature_metadata'], 'r') as file:
        feature_metadata = yaml.safe_load(file)
    return feature_metadata

def save_feature_metadata(feature_metadata):
    paths = load_paths()
    with open(paths['config']['feature_metadata'], 'w') as file:
        file.write("# config/features_metadata.yaml\n\n")
        yaml.dump(feature_metadata, file)

def update_feature_metadata_with_inferred_types(feature_metadata, inferred_types):
    for feature, inferred_type in inferred_types.items():
        if feature in feature_metadata['features']:
            feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
            feature_metadata['features'][feature]['classified_data_type'] = classify_data_type(feature_metadata['features'][feature])
        else:
            feature_metadata['features'][feature] = {
                'description': '',
                'data_type': inferred_type,  # Set inferred type as the main data type if it doesn't exist
                'importance': '',
                'data_source': '',
                'missing_values': '',
                'transformation': '',
                'feature_engineering': '',
                'correlation_with_target': '',
                'distribution': '',
                'data_quality': '',
                'security_implications': '',
                'inferred_data_type': inferred_type,
                'classified_data_type': classify_data_type({'data_type': inferred_type})
            }
    return feature_metadata

def classify_data_type(metadata):
    data_type = metadata.get('data_type', '').lower()
    inferred_data_type = metadata.get('inferred_data_type', '').lower()
    distribution = metadata.get('distribution', '').lower()

    if distribution == 'binary' or data_type in ['int8', 'bool'] or inferred_data_type in ['int8', 'bool']:
        return 'binary'
    elif data_type in ['float32', 'float64', 'int64'] or inferred_data_type in ['float32', 'float64', 'int64']:
        return 'numerical'
    else:
        return 'categorical'

def update_missing_values(feature_metadata, df):
    missing_values = df.isnull().mean() * 100
    for feature in feature_metadata['features']:
        if feature in missing_values:
            feature_metadata['features'][feature]['missing_values'] = f"{missing_values[feature]:.2f}%"
    return feature_metadata

# Optionally add more update functions (e.g., update_correlation_with_target, update_data_quality) based on your needs

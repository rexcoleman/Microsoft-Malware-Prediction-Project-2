# src/feature_engineering/imputation.py

import yaml
from src.config_loader import load_paths

<<<<<<< HEAD
def load_feature_metadata():
    paths = load_paths()
    with open(paths['config']['feature_metadata'], 'r') as file:
        feature_metadata = yaml.safe_load(file)
    return feature_metadata

def parse_missing_percentage(missing_value_str):
    # Remove any non-numeric characters and convert to float
    return float(''.join(filter(str.isdigit, missing_value_str))) / 100.0

def update_feature_metadata_with_inferred_types(feature_metadata, inferred_types):
    for feature, inferred_type in inferred_types.items():
        if feature in feature_metadata['features']:
            feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
        else:
            feature_metadata['features'][feature] = {
                'description': '',
                'data_type': inferred_type,  # Set inferred type as the main data type if it doesn't exist
                'importance': '',
                'data_source': '',
                'missing_values': '',
                'transformation': '',
                'feature_engineering': '',
                'correlation_with_target': '',
                'distribution': '',
                'data_quality': '',
                'security_implications': '',
                'inferred_data_type': inferred_type
            }
    return feature_metadata

def save_feature_metadata(feature_metadata):
    paths = load_paths()
    with open(paths['config']['feature_metadata'], 'w') as file:
        yaml.dump(feature_metadata, file)

def define_imputation_strategies(feature_metadata):
    imputation_strategies = {
        'numerical_features': {},
        'categorical_features': {},
        'binary_features': {}
    }
    
    for feature, metadata in feature_metadata['features'].items():
        missing_percentage = parse_missing_percentage(metadata['missing_values'])
        
        if metadata['data_type'] == 'numerical':
            if missing_percentage < 0.05:
                imputation_strategies['numerical_features'][feature] = 'mean'
            elif 0.05 <= missing_percentage < 0.20:
                imputation_strategies['numerical_features'][feature] = 'median'
            else:
                imputation_strategies['numerical_features'][feature] = 'mode'
        
        elif metadata['data_type'] == 'category':
            if missing_percentage < 0.05:
                imputation_strategies['categorical_features'][feature] = 'mode'
            else:
                imputation_strategies['categorical_features'][feature] = 'Unknown'
        
        elif metadata['data_type'] == 'binary':
            imputation_strategies['binary_features'][feature] = 'mode'
    
    return imputation_strategies

def save_imputation_strategies(imputation_strategies):
    paths = load_paths()
    with open(paths['config']['imputation_strategies'], 'w') as file:
        yaml.dump(imputation_strategies, file)
=======
def suggest_imputation_strategy(summary_stats, corr_matrix, target_col='HasDetections'):
    """
    Suggest imputation strategies based on summary statistics and correlation matrix.

    Parameters:
    - summary_stats (DataFrame): The summary statistics of the dataframe.
    - corr_matrix (DataFrame): The correlation matrix of the dataframe.
    - target_col (str): The target column for correlation analysis.

    Returns:
    - dict: Imputation strategies for each column.
    """
    strategies = {}
    for column in summary_stats.index:
        if summary_stats.loc[column, 'missing_values'] > 0:
            if 'dtype' in summary_stats.columns and summary_stats.loc[column, 'dtype'] in ['float64', 'int64']:
                if abs(corr_matrix[target_col].get(column, 0)) > 0.1:
                    strategies[column] = 'median'  # For numerical columns with significant correlation, use median
                else:
                    strategies[column] = 'mean'  # For numerical columns without significant correlation, use mean
            else:
                strategies[column] = 'mode'  # For categorical columns, use mode
    return strategies
>>>>>>> efcef556054e798cdc6a7e915a5d9496fcc2f923









# import pandas as pd

# def suggest_imputation_strategy(summary_stats, corr_matrix, target_col='HasDetections'):
#     strategies = {}
#     for column in summary_stats.index:
#         if summary_stats.loc[column, 'missing_values'] > 0:
#             if summary_stats.loc[column, 'dtype'] in ['float64', 'int64']:
#                 if abs(corr_matrix[target_col].get(column, 0)) > 0.1:
#                     strategies[column] = 'median'  # For numerical columns with significant correlation, use median
#                 else:
#                     strategies[column] = 'mean'  # For other numerical columns, use mean
#             elif summary_stats.loc[column, 'dtype'] == 'object':
#                 strategies[column] = 'mode'  # For categorical columns, use mode
#             elif summary_stats.loc[column, 'dtype'] == 'category':
#                 strategies[column] = 'mode'  # For categorical columns, use mode
#     return {'imputation_strategies': strategies}





# # def suggest_imputation_strategy(summary_stats, corr_matrix, target_col='HasDetections'):
# #     """
# #     Suggest imputation strategies based on summary statistics and correlation matrix.

# #     Parameters:
# #     - summary_stats (DataFrame): Summary statistics.
# #     - corr_matrix (DataFrame): Correlation matrix.
# #     - target_col (str): The target column for correlation analysis.

# #     Returns:
# #     - dict: Suggested imputation strategies.
# #     """
# #     strategies = {}
# #     for column in summary_stats.index:
# #         if summary_stats.loc[column, 'missing_values'] > 0:
# #             if summary_stats.loc[column, 'dtype'] in ['float64', 'int64']:
# #                 if abs(corr_matrix[target_col].get(column, 0)) > 0.1:
# #                     strategies[column] = 'median'  # For numerical columns with significant correlation, use median
# #                 else:
# #                     strategies[column] = 'mean'    # For numerical columns with low correlation, use mean
# #             else:
# #                 strategies[column] = 'mode'        # For categorical columns, use mode
# #     return strategies

# def handle_missing_values(df, imputation_strategies):
#     """
#     Handle missing values in the dataframe based on suggested imputation strategies.

#     Parameters:
#     - df (DataFrame): The dataframe with missing values.
#     - imputation_strategies (dict): Dictionary of imputation strategies.

#     Returns:
#     - DataFrame: Dataframe with imputed values.
#     """
#     for column, strategy in imputation_strategies.items():
#         if strategy == 'median':
#             df[column].fillna(df[column].median(), inplace=True)
#         elif strategy == 'mean':
#             df[column].fillna(df[column].mean(), inplace=True)
#         elif strategy == 'mode':
#             df[column].fillna(df[column].mode()[0], inplace=True)
#     return df

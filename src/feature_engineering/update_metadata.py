# src/feature_engineering/update_metadata.py

import yaml
import pandas as pd
from src.config_loader import load_paths

def load_feature_metadata():
    paths = load_paths()
    with open(paths['config']['feature_metadata'], 'r') as file:
        feature_metadata = yaml.safe_load(file)
    return feature_metadata

def save_feature_metadata(feature_metadata):
    paths = load_paths()
    with open(paths['config']['feature_metadata'], 'w') as file:
        file.write("# config/feature_metadata.yaml\n\n")  # Ensure the commented file path is added
        yaml.dump(feature_metadata, file)

def load_feature_metadata_schema():
    paths = load_paths()
    with open(paths['config']['feature_metadata_schema'], 'r') as file:
        schema = yaml.safe_load(file)
    return schema['default_attributes']

def update_feature_metadata_with_schema(feature_metadata):
    schema = load_feature_metadata_schema()
    for feature in feature_metadata['features']:
        for key, default_value in schema.items():
            if key not in feature_metadata['features'][feature]:
                feature_metadata['features'][feature][key] = default_value
    return feature_metadata

def update_feature_metadata_with_inferred_types(feature_metadata, inferred_types):
    schema = load_feature_metadata_schema()
    for feature, inferred_type in inferred_types.items():
        if feature in feature_metadata['features']:
            feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
            feature_metadata['features'][feature]['classified_data_type'] = classify_data_type(feature_metadata['features'][feature])
        else:
            feature_metadata['features'][feature] = schema.copy()  # Use schema as a template
            feature_metadata['features'][feature]['data_type'] = inferred_type
            feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
            feature_metadata['features'][feature]['classified_data_type'] = classify_data_type({'data_type': inferred_type})
    return update_feature_metadata_with_schema(feature_metadata)

def classify_data_type(metadata):
    data_type = metadata.get('data_type', '').lower()
    inferred_data_type = metadata.get('inferred_data_type', '').lower()
    distribution = metadata.get('distribution', '').lower()

    if distribution == 'binary' or data_type in ['int8', 'bool'] or inferred_data_type in ['int8', 'bool']:
        return 'binary'
    elif data_type in ['float32', 'float64', 'int64'] or inferred_data_type in ['float32', 'float64', 'int64']:
        return 'numerical'
    else:
        return 'categorical'

def update_missing_values(feature_metadata, df):
    schema = load_feature_metadata_schema()
    for feature in df.columns:
        missing_percentage = df[feature].isnull().mean() * 100
        example_values = df[feature].dropna().unique()[:3].tolist()
        summary_statistics = df[feature].describe().to_dict()
        
        if feature in feature_metadata['features']:
            feature_metadata['features'][feature]['missing_values'] = f"{missing_percentage:.2f}%"
            feature_metadata['features'][feature]['example_values'] = example_values
            feature_metadata['features'][feature]['summary_statistics'] = summary_statistics
        else:
            feature_metadata['features'][feature] = schema.copy()  # Use schema as a template
            feature_metadata['features'][feature]['data_type'] = str(df[feature].dtype)
            feature_metadata['features'][feature]['inferred_data_type'] = str(df[feature].dtype)
            feature_metadata['features'][feature]['classified_data_type'] = classify_data_type({'data_type': str(df[feature].dtype)})
            feature_metadata['features'][feature]['missing_values'] = f"{missing_percentage:.2f}%"
            feature_metadata['features'][feature]['example_values'] = example_values
            feature_metadata['features'][feature]['summary_statistics'] = summary_statistics
    return update_feature_metadata_with_schema(feature_metadata)





# # src/feature_engineering/update_metadata.py

# import yaml
# import pandas as pd
# from src.config_loader import load_paths

# def load_feature_metadata():
#     paths = load_paths()
#     with open(paths['config']['feature_metadata'], 'r') as file:
#         feature_metadata = yaml.safe_load(file)
#     return feature_metadata

# def save_feature_metadata(feature_metadata):
#     paths = load_paths()
#     with open(paths['config']['feature_metadata'], 'w') as file:
#         file.write("# config/feature_metadata.yaml\n\n")  # Ensure the commented file path is added
#         yaml.dump(feature_metadata, file)

# def load_feature_metadata_schema():
#     paths = load_paths()
#     with open(paths['config']['feature_metadata_schema'], 'r') as file:  # Use correct path
#         schema = yaml.safe_load(file)
#     return schema['default_attributes']

# def update_feature_metadata_with_schema(feature_metadata):
#     schema = load_feature_metadata_schema()
#     for feature in feature_metadata['features']:
#         for key, default_value in schema.items():
#             if key not in feature_metadata['features'][feature]:
#                 feature_metadata['features'][feature][key] = default_value
#     return feature_metadata

# def update_feature_metadata_with_inferred_types(feature_metadata, inferred_types):
#     schema = load_feature_metadata_schema()
#     for feature, inferred_type in inferred_types.items():
#         if feature in feature_metadata['features']:
#             feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
#             feature_metadata['features'][feature]['classified_data_type'] = classify_data_type(feature_metadata['features'][feature])
#         else:
#             feature_metadata['features'][feature] = schema.copy()  # Use schema as a template
#             feature_metadata['features'][feature]['data_type'] = inferred_type
#             feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
#             feature_metadata['features'][feature]['classified_data_type'] = classify_data_type({'data_type': inferred_type})
#     return update_feature_metadata_with_schema(feature_metadata)

# def classify_data_type(metadata):
#     data_type = metadata.get('data_type', '').lower()
#     inferred_data_type = metadata.get('inferred_data_type', '').lower()
#     distribution = metadata.get('distribution', '').lower()

#     if distribution == 'binary' or data_type in ['int8', 'bool'] or inferred_data_type in ['int8', 'bool']:
#         return 'binary'
#     elif data_type in ['float32', 'float64', 'int64'] or inferred_data_type in ['float32', 'float64', 'int64']:
#         return 'numerical'
#     else:
#         return 'categorical'

# def update_missing_values(feature_metadata, df):
#     schema = load_feature_metadata_schema()
#     for feature in df.columns:
#         missing_percentage = df[feature].isnull().mean() * 100
#         example_values = df[feature].dropna().unique()[:3].tolist()
#         summary_statistics = df[feature].describe().to_dict()
        
#         if feature in feature_metadata['features']:
#             feature_metadata['features'][feature]['missing_values'] = f"{missing_percentage:.2f}%"
#             feature_metadata['features'][feature]['example_values'] = example_values
#             feature_metadata['features'][feature]['summary_statistics'] = summary_statistics
#         else:
#             feature_metadata['features'][feature] = schema.copy()  # Use schema as a template
#             feature_metadata['features'][feature]['data_type'] = str(df[feature].dtype)
#             feature_metadata['features'][feature]['inferred_data_type'] = str(df[feature].dtype)
#             feature_metadata['features'][feature]['classified_data_type'] = classify_data_type({'data_type': str(df[feature].dtype)})
#             feature_metadata['features'][feature]['missing_values'] = f"{missing_percentage:.2f}%"
#             feature_metadata['features'][feature]['example_values'] = example_values
#             feature_metadata['features'][feature]['summary_statistics'] = summary_statistics
#     return update_feature_metadata_with_schema(feature_metadata)





# # # src/feature_engineering/update_metadata.py

# # import yaml
# # import pandas as pd
# # from src.config_loader import load_paths

# # def load_feature_metadata():
# #     paths = load_paths()
# #     with open(paths['config']['feature_metadata'], 'r') as file:
# #         feature_metadata = yaml.safe_load(file)
# #     return feature_metadata

# # def save_feature_metadata(feature_metadata):
# #     paths = load_paths()
# #     with open(paths['config']['feature_metadata'], 'w') as file:
# #         yaml.dump(feature_metadata, file)

# # def load_feature_metadata_schema():
# #     paths = load_paths()
# #     with open(paths['config']['feature_metadata_schema'], 'r') as file:  # Use correct path
# #         schema = yaml.safe_load(file)
# #     return schema['default_attributes']

# # def update_feature_metadata_with_schema(feature_metadata):
# #     schema = load_feature_metadata_schema()
# #     for feature in feature_metadata['features']:
# #         for key, default_value in schema.items():
# #             if key not in feature_metadata['features'][feature]:
# #                 feature_metadata['features'][feature][key] = default_value
# #     return feature_metadata

# # def update_feature_metadata_with_inferred_types(feature_metadata, inferred_types):
# #     for feature, inferred_type in inferred_types.items():
# #         if feature in feature_metadata['features']:
# #             feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
# #             feature_metadata['features'][feature]['classified_data_type'] = classify_data_type(feature_metadata['features'][feature])
# #         else:
# #             feature_metadata['features'][feature] = {
# #                 'description': '',
# #                 'data_type': inferred_type,
# #                 'importance': '',
# #                 'data_source': '',
# #                 'missing_values': '',
# #                 'transformation': '',
# #                 'feature_engineering': '',
# #                 'correlation_with_target': '',
# #                 'distribution': '',
# #                 'data_quality': '',
# #                 'security_implications': '',
# #                 'inferred_data_type': inferred_type,
# #                 'classified_data_type': classify_data_type({'data_type': inferred_type}),
# #                 'example_values': [],
# #                 'summary_statistics': {}
# #             }
# #     return update_feature_metadata_with_schema(feature_metadata)

# # def classify_data_type(metadata):
# #     data_type = metadata.get('data_type', '').lower()
# #     inferred_data_type = metadata.get('inferred_data_type', '').lower()
# #     distribution = metadata.get('distribution', '').lower()

# #     if distribution == 'binary' or data_type in ['int8', 'bool'] or inferred_data_type in ['int8', 'bool']:
# #         return 'binary'
# #     elif data_type in ['float32', 'float64', 'int64'] or inferred_data_type in ['float32', 'float64', 'int64']:
# #         return 'numerical'
# #     else:
# #         return 'categorical'

# # def update_missing_values(feature_metadata, df):
# #     for feature in df.columns:
# #         missing_percentage = df[feature].isnull().mean() * 100
# #         example_values = df[feature].dropna().unique()[:3].tolist()
# #         summary_statistics = df[feature].describe().to_dict()
        
# #         if feature in feature_metadata['features']:
# #             feature_metadata['features'][feature]['missing_values'] = f"{missing_percentage:.2f}%"
# #             feature_metadata['features'][feature]['example_values'] = example_values
# #             feature_metadata['features'][feature]['summary_statistics'] = summary_statistics
# #         else:
# #             feature_metadata['features'][feature] = {
# #                 'description': '',
# #                 'data_type': str(df[feature].dtype),
# #                 'importance': '',
# #                 'data_source': '',
# #                 'missing_values': f"{missing_percentage:.2f}%",
# #                 'transformation': '',
# #                 'feature_engineering': '',
# #                 'correlation_with_target': '',
# #                 'distribution': '',
# #                 'data_quality': '',
# #                 'security_implications': '',
# #                 'inferred_data_type': str(df[feature].dtype),
# #                 'classified_data_type': classify_data_type({'data_type': str(df[feature].dtype)}),
# #                 'example_values': example_values,
# #                 'summary_statistics': summary_statistics
# #             }
# #     return update_feature_metadata_with_schema(feature_metadata)





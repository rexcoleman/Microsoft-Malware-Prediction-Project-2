# src/feature_engineering/feature_utils.py

import pandas as pd
from tqdm.notebook import tqdm
import logging
from typing import List, Tuple
from src.feature_engineering.shared_utils import extract_missing_percentage, should_label_missing
from src.utils.metadata_operations import extract_imputation_strategy

def drop_features(data: pd.DataFrame, metadata: dict) -> Tuple[pd.DataFrame, List[str]]:
    """
    Identify and drop features flagged for dropping.

    Parameters:
    - data (pd.DataFrame): The DataFrame from which to drop features.
    - metadata (dict): Metadata containing feature information.

    Returns:
    - Tuple[pd.DataFrame, List[str]]: A tuple containing the DataFrame with features dropped and a list of dropped features.
    """
    features_to_drop = [
        feature for feature in metadata['features'].keys() 
        if extract_imputation_strategy(metadata, feature) == 'Drop'
    ]
    data.drop(columns=features_to_drop, inplace=True)
    return data, features_to_drop



def label_missing_values(data: pd.DataFrame, metadata: dict, features_to_drop: List[str], is_train: bool = True) -> Tuple[pd.DataFrame, List[str]]:
    essential_missing_indicators = []
    
    for feature in tqdm(metadata['features'].keys(), desc="Labeling missing values"):
        # Skip the target variable in the training set
        if is_train and feature == 'HasDetections':
            continue

        # Check if the feature is in the drop list before creating a missing indicator
        if feature not in features_to_drop:
            missing_percentage = extract_missing_percentage(metadata, feature)
            actual_missing_count = data[feature].isnull().sum()
            logging.info(f"Metadata missing percentage for feature '{feature}': {missing_percentage}%")
            
            if actual_missing_count > 0:
                logging.info(f"Actual missing count for feature '{feature}': {actual_missing_count}")
                if should_label_missing(missing_percentage):
                    missing_indicator = f'{feature}_is_missing'
                    
                    # Calculate the missing indicator
                    data[missing_indicator] = data[feature].isnull().astype(int)
                    essential_missing_indicators.append(missing_indicator)
                    
                    # Log the number of missing values for this feature
                    missing_count = data[missing_indicator].sum()
                    logging.info(f"Missing values detected for feature '{feature}': {missing_count}")
                    
                    # Validate that the missing indicator was calculated correctly
                    assert missing_count == actual_missing_count, (
                        f"Mismatch in missing value count for feature '{feature}'. Expected: {actual_missing_count}, Found: {missing_count}."
                    )
            else:
                logging.info(f"No missing values detected for feature '{feature}'.")
                
    return data, essential_missing_indicators




def add_essential_missing_value_features(data: pd.DataFrame, metadata: dict, features_to_drop: List[str], is_train: bool = True) -> pd.DataFrame:
    """
    Add essential missing value features to the dataset.
    
    Parameters:
    data (DataFrame): The dataset (train or test).
    metadata (dict): Metadata containing information about the features.
    features_to_drop (List[str]): List of features to drop, which should not have missing indicators.
    is_train (bool): Whether the data is the training set (default: True).

    Returns:
    DataFrame: The dataset with essential missing value features added.
    """
    data, essential_missing_indicators = label_missing_values(data, metadata, features_to_drop, is_train)
    logging.info(f"Essential missing indicators added: {essential_missing_indicators}")
    return data
























# def label_missing_values(data: pd.DataFrame, metadata: dict, features_to_drop: List[str], is_train: bool = True) -> Tuple[pd.DataFrame, List[str]]:
#     essential_missing_indicators = []
    
#     for feature in tqdm(metadata['features'].keys(), desc="Labeling missing values"):
#         # Skip the target variable in the training set
#         if is_train and feature == 'HasDetections':
#             continue

#         # Check if the feature is in the drop list before creating a missing indicator
#         if feature not in features_to_drop:
#             missing_percentage = extract_missing_percentage(metadata, feature)
#             actual_missing_count = data[feature].isnull().sum()
#             logging.info(f"Actual missing count for feature '{feature}': {actual_missing_count}")
#             logging.info(f"Metadata missing percentage for feature '{feature}': {missing_percentage}%")
            
#             if should_label_missing(missing_percentage):
#                 missing_indicator = f'{feature}_is_missing'
                
#                 # Calculate the missing indicator
#                 data[missing_indicator] = data[feature].isnull().astype(int)
#                 essential_missing_indicators.append(missing_indicator)
                
#                 # Log the number of missing values for this feature
#                 missing_count = data[missing_indicator].sum()
#                 logging.info(f"Missing values detected for feature '{feature}': {missing_count}")
                
#                 # Validate that the missing indicator was calculated correctly
#                 assert missing_count == actual_missing_count, (
#                     f"Mismatch in missing value count for feature '{feature}'. Expected: {actual_missing_count}, Found: {missing_count}."
#                 )
                
#     return data, essential_missing_indicators










# def label_missing_values(data: pd.DataFrame, metadata: dict, features_to_drop: List[str]) -> Tuple[pd.DataFrame, List[str]]:
#     essential_missing_indicators = []
    
#     for feature in tqdm(metadata['features'].keys(), desc="Labeling missing values"):
#         # Check if the feature is in the drop list before creating a missing indicator
#         if feature not in features_to_drop:
#             missing_percentage = extract_missing_percentage(metadata, feature)
#             if should_label_missing(missing_percentage):
#                 missing_indicator = f'{feature}_is_missing'
                
#                 # Calculate the missing indicator
#                 data[missing_indicator] = data[feature].isnull().astype(int)
#                 essential_missing_indicators.append(missing_indicator)
                
#                 # Log the number of missing values for this feature
#                 missing_count = data[missing_indicator].sum()
#                 logging.info(f"{missing_count} missing values detected for feature '{feature}'")
                
#                 # Validate that the missing indicator was calculated correctly
#                 assert missing_count == data[feature].isnull().sum(), (
#                     f"Mismatch in missing value count for feature '{feature}'."
#                 )
                
#     return data, essential_missing_indicators


# def label_missing_values(data: pd.DataFrame, metadata: dict, features_to_drop: List[str]) -> Tuple[pd.DataFrame, List[str]]:
#     essential_missing_indicators = []
    
#     for feature in tqdm(metadata['features'].keys(), desc="Labeling missing values"):
#         # Check if the feature is in the drop list before creating a missing indicator
#         if feature not in features_to_drop:
#             missing_percentage = extract_missing_percentage(metadata, feature)
#             actual_missing_count = data[feature].isnull().sum()
#             logging.info(f"Actual missing count for feature '{feature}': {actual_missing_count}")
#             logging.info(f"Metadata missing percentage for feature '{feature}': {missing_percentage}%")
            
#             if should_label_missing(missing_percentage):
#                 missing_indicator = f'{feature}_is_missing'
                
#                 # Calculate the missing indicator
#                 data[missing_indicator] = data[feature].isnull().astype(int)
#                 essential_missing_indicators.append(missing_indicator)
                
#                 # Log the number of missing values for this feature
#                 missing_count = data[missing_indicator].sum()
#                 logging.info(f"Missing values detected for feature '{feature}': {missing_count}")
                
#                 # Validate that the missing indicator was calculated correctly
#                 assert missing_count == actual_missing_count, (
#                     f"Mismatch in missing value count for feature '{feature}'. Expected: {actual_missing_count}, Found: {missing_count}."
#                 )
                
#     return data, essential_missing_indicators

# src/feature_engineering/utils.py

import pandas as pd
import yaml
from tqdm.notebook import tqdm
import logging
from src.config_loader import load_paths
from src.utils.metadata_operations import extract_classified_data_type

def load_feature_metadata():
    paths = load_paths()
    with open(paths['config']['feature_metadata'], 'r') as file:
        feature_metadata = yaml.safe_load(file)
    return feature_metadata

def load_feature_metadata_schema():
    paths = load_paths()
    with open(paths['config']['feature_metadata_schema'], 'r') as file:
        schema = yaml.safe_load(file)
    return schema['default_attributes']

def classify_data_type(metadata):
    data_type = metadata.get('data_type', '').lower()
    inferred_data_type = metadata.get('inferred_data_type', '').lower()
    distribution = metadata.get('distribution', '').lower()

    if distribution == 'binary' or data_type in ['int8', 'bool'] or inferred_data_type in ['int8', 'bool']:
        return 'binary'
    elif data_type in ['float32', 'float64', 'int64'] or inferred_data_type in ['float32', 'float64', 'int64']:
        return 'numerical'
    else:
        return 'categorical'

def update_feature_metadata_with_inferred_types(feature_metadata, inferred_types):
    schema = load_feature_metadata_schema()
    for feature, inferred_type in inferred_types.items():
        if feature in feature_metadata['features']:
            feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
            feature_metadata['features'][feature]['classified_data_type'] = classify_data_type(feature_metadata['features'][feature])
        else:
            feature_metadata['features'][feature] = schema.copy()  # Use schema as a template
            feature_metadata['features'][feature]['data_type'] = inferred_type
            feature_metadata['features'][feature]['inferred_data_type'] = inferred_type
            feature_metadata['features'][feature]['classified_data_type'] = classify_data_type({'data_type': inferred_type})
    return feature_metadata

def save_feature_metadata(feature_metadata):
    paths = load_paths()
    with open(paths['config']['feature_metadata'], 'w') as file:
        file.write("# config/features_metadata.yaml\n\n")
        yaml.dump(feature_metadata, file)


def convert_data_types(data, metadata):
    for feature in tqdm(metadata['features'].keys(), desc="Converting data types"):
        if feature in data.columns:
            classified_data_type = extract_classified_data_type(metadata, feature)
            technical_data_type = map_classified_to_technical(classified_data_type) or extract_technical_data_type(metadata, feature)
            
            if technical_data_type:
                try:
                    if technical_data_type == 'int64':
                        data[feature] = pd.to_numeric(data[feature], errors='coerce').astype('int64')
                    elif technical_data_type == 'float64':
                        data[feature] = pd.to_numeric(data[feature], errors='coerce').astype('float64')
                    elif technical_data_type == 'object':
                        data[feature] = data[feature].astype(str)
                    elif technical_data_type == 'datetime':
                        data[feature] = pd.to_datetime(data[feature], errors='coerce')
                    logging.info(f"Converted feature '{feature}' to '{technical_data_type}'.")
                except Exception as e:
                    logging.error(f"Error converting feature '{feature}' to '{technical_data_type}': {e}")
            else:
                logging.warning(f"Technical data type not mapped for classified data type '{classified_data_type}' for feature '{feature}'")
        else:
            logging.warning(f"Feature '{feature}' not found in data.")
    return data


def map_classified_to_technical(classified_type: str) -> str:
    """
    Map classified data types to technical data types.
    
    Parameters:
    classified_type (str): The classified data type (binary, numerical, categorical).
    
    Returns:
    str: The corresponding technical data type (int, float, object).
    """
    if classified_type == 'binary':
        return 'int64'  # Could also use 'bool' if preferred
    elif classified_type == 'numerical':
        return 'float64'  # Assume float for more flexibility
    elif classified_type == 'categorical':
        return 'object'
    else:
        return None

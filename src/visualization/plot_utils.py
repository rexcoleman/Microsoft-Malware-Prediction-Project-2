# src/visualization/plot_utils.py

import seaborn as sns
import matplotlib.pyplot as plt
from IPython.display import Image, display, HTML

def set_plot_style(style: str = "seaborn-darkgrid") -> None:
    """
    Set the style for seaborn plots.

    Parameters:
    style (str, optional): The style to set for seaborn plots. Defaults to "seaborn-darkgrid".
    """
    sns.set_style(style)

def save_figure(fig: plt.Figure, path: str) -> None:
    """
    Save a matplotlib figure to the specified path.

    Parameters:
    fig (matplotlib.figure.Figure): The figure to save.
    path (str): The path where the figure should be saved.
    """
    try:
        fig.savefig(path, bbox_inches='tight')
        print(f"Figure saved to {path}")
    except Exception as e:
        print(f"Error saving figure to {path}: {e}")

def create_subplots(nrows: int, ncols: int, figsize: tuple = (15, 10)) -> tuple:
    """
    Create a set of subplots with the specified number of rows and columns.

    Parameters:
    nrows (int): Number of rows of subplots.
    ncols (int): Number of columns of subplots.
    figsize (tuple, optional): Size of the figure. Defaults to (15, 10).

    Returns:
    fig (matplotlib.figure.Figure): The created figure.
    axes (numpy.ndarray): Array of Axes objects.
    """
    fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize)
    return fig, axes












# # src/visualization/plot_utils.py



# def plot_histogram(data, feature, ax):
#     sns.histplot(data[feature], kde=True, bins=30, ax=ax)
#     ax.set_title(f'Distribution of {feature}')
#     ax.set_xlabel(feature)
#     ax.set_ylabel('Frequency')

# def plot_boxplot(data, feature, ax):
#     sns.boxplot(y=data[feature], ax=ax)
#     ax.set_title(f'Box Plot of {feature}')
#     ax.set_ylabel(feature)

# def plot_kde(data, feature, ax):
#     if pd.api.types.is_numeric_dtype(data[feature]):
#         sns.kdeplot(data[feature], fill=True, warn_singular=False, ax=ax)
#         ax.set_title(f'Kernel Density Estimate of {feature}')
#         ax.set_xlabel(feature)
#         ax.set_ylabel('Density')
#     else:
#         ax.set_title(f'KDE not applicable for {feature}')
#         ax.axis('off')

# def plot_countplot(data, feature, ax, top_n=10):
#     value_counts = data[feature].value_counts().head(top_n)
#     sns.barplot(x=value_counts.index, y=value_counts.values, ax=ax)
#     ax.set_title(f'Top {top_n} Categories of {feature}')
#     ax.set_xlabel(feature)
#     ax.set_ylabel('Count')
#     ax.set_xticklabels(ax.get_xticklabels(), rotation=45)

# def plot_piechart(labels, sizes, ax, feature):
#     ax.pie(sizes, labels=labels, autopct='%1.1f%%')
#     ax.set_title(f'Top {len(labels)} Categories of {feature}')

# def plot_binary_feature(data, feature, ax):
#     sns.countplot(x=data[feature], ax=ax)
#     ax.set_title(f'Count Plot of {feature}')
#     ax.set_xlabel(f'{feature} Value')
#     ax.set_ylabel('Count')
#     total = len(data[feature].dropna())
#     for p in ax.patches:
#         height = p.get_height()
#         ax.text(p.get_x() + p.get_width() / 2., height + 3, '{:1.2f}%'.format(100 * height / total), ha="center")


# # src/visualization/plot_utils.py


# def plot_heatmap(corr_matrix, title, save_path=None, annot=False):
#     plt.figure(figsize=(15, 10))
#     sns.heatmap(corr_matrix, annot=annot, cmap='coolwarm', fmt='.2f')
#     plt.title(title)
#     if save_path:
#         plt.savefig(save_path)
#     plt.show()

# def plot_barplot(correlation_df, title, save_path=None):
#     plt.figure(figsize=(12, 8))
#     sns.barplot(x='Correlation', y='Feature', data=correlation_df, hue='Feature', dodge=False, palette='coolwarm', legend=False)
#     plt.title(title)
#     plt.xlabel('Correlation')
#     plt.ylabel('Feature')
#     if save_path:
#         plt.savefig(save_path)
#     plt.show()

# def orchestrate_outlier_plots_initial_analysis(data, outlier_metrics_df, output_plot_dir, output_table_dir, plot_type='before'):
#     for feature in tqdm(data.columns, desc=f"Creating {plot_type} plots"):
#         if data[feature].dtype in ['float64', 'int64']:
#             output_plot_path = create_outlier_plots(data, feature, output_plot_dir, plot_type)

#             # Create a summary table
#             summary_data = {
#                 'Metric': ['Z-Score Outliers', 'IQR Outliers', 'Z-Score Outliers (%)', 'IQR Outliers (%)', 'MAD Scores', 'Isolation Forest Outliers', 'LOF Outliers', 'DBSCAN Outliers', 'Skewness', 'Kurtosis'],
#                 'Value': [
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Z-Score Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['IQR Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Z-Score Outliers (%)'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['IQR Outliers (%)'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['MAD Scores'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Isolation Forest Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['LOF Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['DBSCAN Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Skewness'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Kurtosis'].values[0]
#                 ]
#             }
#             summary_df = pd.DataFrame(summary_data)

#             # Save the summary table
#             output_table_path = os.path.join(output_table_dir, f'{feature}_outlier_analysis_summary_{plot_type}.csv')
#             save_dataframe(summary_df, output_table_path)

#             # Create a separate figure for the table
#             fig, ax = plt.subplots(figsize=(12, 2))  # Adjust height to fit the table
#             ax.axis('off')
#             table = ax.table(cellText=summary_df.values, colLabels=summary_df.columns, cellLoc='center', loc='center')
#             table.scale(1, 2)
#             plt.tight_layout()

#             # Save the table as a separate figure
#             output_table_plot_path = os.path.join(output_plot_dir, f'{feature}_outlier_analysis_table_{plot_type}.png')
#             plt.savefig(output_table_plot_path)
#             plt.show()  # Display the table inline
#             plt.close(fig)

#             # Display plots and table inline in notebook
#             from IPython.display import Image, display
#             display(Image(filename=output_plot_path))
#             display(summary_df)
#             display(Image(filename=output_table_plot_path))

# def create_outlier_plots(data, feature, output_plot_dir, plot_type='before'):
#     fig, ax = plt.subplots(2, 2, figsize=(12, 12))

#     sns.boxplot(x=data[feature], ax=ax[0, 0])
#     ax[0, 0].set_title(f"Box Plot of {feature} ({plot_type})")

#     sns.histplot(data[feature], bins=30, kde=True, ax=ax[0, 1])
#     ax[0, 1].set_title(f"Histogram of {feature} ({plot_type})")

#     sns.scatterplot(x=data.index, y=data[feature], ax=ax[1, 0])
#     ax[1, 0].set_title(f"Scatter Plot of {feature} ({plot_type})")
#     ax[1, 0].set_xlabel('Index')

#     sns.violinplot(x=data[feature], ax=ax[1, 1])
#     ax[1, 1].set_title(f"Violin Plot of {feature} ({plot_type})")

#     plt.tight_layout()

#     # Save the combined plot as a figure
#     output_plot_path = os.path.join(output_plot_dir, f'{feature}_outlier_analysis_{plot_type}.png')
#     fig.savefig(output_plot_path)
#     plt.close(fig)

#     return output_plot_path

# def create_side_by_side_comparison_plots(before_data, after_data, before_metrics, after_metrics, feature, output_plot_dir, strategy):
#     fig, axes = plt.subplots(2, 2, figsize=(18, 10))

#     sns.histplot(before_data[feature], bins=30, kde=True, ax=axes[0, 0], color='blue')
#     axes[0, 0].set_title(f'{feature} Before Transformation')

#     sns.histplot(after_data[feature], bins=30, kde=True, ax=axes[0, 1], color='green')
#     axes[0, 1].set_title(f'{feature} After Transformation')

#     before_stats = before_metrics[before_metrics['Feature'] == feature]
#     after_stats = after_metrics[after_metrics['Feature'] == feature]

#     before_text = (
#         f"Before:\n"
#         f"Z-Score Outliers: {before_stats['Z-Score Outliers'].values[0]}\n"
#         f"IQR Outliers: {before_stats['IQR Outliers'].values[0]}\n"
#         f"MAD Scores: {before_stats['MAD Scores'].values[0]}\n"
#         f"Isolation Forest Outliers: {before_stats['Isolation Forest Outliers'].values[0]}\n"
#         f"LOF Outliers: {before_stats['LOF Outliers'].values[0]}\n"
#         f"DBSCAN Outliers: {before_stats['DBSCAN Outliers'].values[0]}\n"
#         f"Skewness: {before_stats['Skewness'].values[0]}\n"
#         f"Kurtosis: {before_stats['Kurtosis'].values[0]}"
#     )
#     after_text = (
#         f"After:\n"
#         f"Z-Score Outliers: {after_stats['Z-Score Outliers'].values[0]}\n"
#         f"IQR Outliers: {after_stats['IQR Outliers'].values[0]}\n"
#         f"MAD Scores: {after_stats['MAD Scores'].values[0]}\n"
#         f"Isolation Forest Outliers: {after_stats['Isolation Forest Outliers'].values[0]}\n"
#         f"LOF Outliers: {after_stats['LOF Outliers'].values[0]}\n"
#         f"DBSCAN Outliers: {after_stats['DBSCAN Outliers'].values[0]}\n"
#         f"Skewness: {after_stats['Skewness'].values[0]}\n"
#         f"Kurtosis: {after_stats['Kurtosis'].values[0]}"
#     )

#     axes[1, 0].axis('off')
#     axes[1, 0].text(0.1, 0.5, before_text, fontsize=12)

#     axes[1, 1].axis('off')
#     axes[1, 1].text(0.1, 0.5, after_text, fontsize=12)

#     plt.tight_layout()
#     output_plot_path = os.path.join(output_plot_dir, f'{feature}_before_after_comparison.png')
#     fig.savefig(output_plot_path)
#     plt.close(fig)

#     # Display plots inline
#     display(Image(filename=output_plot_path))
#     display(HTML(f"<b>Outlier Remediation Strategy: {strategy}</b>"))

#     return before_stats, after_stats

# def orchestrate_side_by_side_comparison(before_data, after_data, before_metrics, after_metrics, metadata, output_plot_dir, output_table_dir):
#     features_to_compare = [
#         (feature, details['outlier_remediation_strategy'])
#         for feature, details in metadata['features'].items() 
#         if 'outlier_remediation_strategy' in details and details['outlier_remediation_strategy'] != 'No Action'
#     ]
    
#     # Sort features by outlier remediation strategy
#     features_to_compare.sort(key=lambda x: x[1])
    
#     comparison_results = []
    
#     for feature, strategy in tqdm(features_to_compare, desc="Creating side-by-side comparison plots"):
#         if before_data[feature].dtype in ['float64', 'int64'] and feature in after_data.columns:
#             before_stats, after_stats = create_side_by_side_comparison_plots(before_data, after_data, before_metrics, after_metrics, feature, output_plot_dir, strategy)
            
#             comparison_results.append({
#                 'Feature': feature,
#                 'Outlier Remediation Strategy': strategy,
#                 'Before Z-Score Outliers': before_stats['Z-Score Outliers'].values[0],
#                 'After Z-Score Outliers': after_stats['Z-Score Outliers'].values[0],
#                 'Before IQR Outliers': before_stats['IQR Outliers'].values[0],
#                 'After IQR Outliers': after_stats['IQR Outliers'].values[0],
#                 'Before MAD Scores': before_stats['MAD Scores'].values[0],
#                 'After MAD Scores': after_stats['MAD Scores'].values[0],
#                 'Before Isolation Forest Outliers': before_stats['Isolation Forest Outliers'].values[0],
#                 'After Isolation Forest Outliers': after_stats['Isolation Forest Outliers'].values[0],
#                 'Before LOF Outliers': before_stats['LOF Outliers'].values[0],
#                 'After LOF Outliers': after_stats['LOF Outliers'].values[0],
#                 'Before DBSCAN Outliers': before_stats['DBSCAN Outliers'].values[0],
#                 'After DBSCAN Outliers': after_stats['DBSCAN Outliers'].values[0],
#                 'Before Skewness': before_stats['Skewness'].values[0],
#                 'After Skewness': after_stats['Skewness'].values[0],
#                 'Before Kurtosis': before_stats['Kurtosis'].values[0],
#                 'After Kurtosis': after_stats['Kurtosis'].values[0]
#             })

#     comparison_df = pd.DataFrame(comparison_results)
    
#     # Save comparison results to CSV and JSON
#     comparison_csv_path = os.path.join(output_table_dir, 'outlier_remediation_comparison.csv')
#     comparison_json_path = os.path.join(output_table_dir, 'outlier_remediation_comparison.json')
#     save_dataframe(comparison_df, comparison_csv_path)
#     save_json_file(comparison_results, comparison_json_path)
    
#     print(f"Comparison results saved to {comparison_csv_path} and {comparison_json_path}")


# def orchestrate_outlier_plots(data, outlier_metrics_df, output_plot_dir, output_table_dir, plot_type='before'):
#     for feature in tqdm(data.columns, desc=f"Creating {plot_type} plots"):
#         if data[feature].dtype in ['float64', 'int64']:
#             output_plot_path = create_outlier_plots(data, feature, output_plot_dir, plot_type)

#             # Create a summary table
#             summary_data = {
#                 'Metric': ['Z-Score Outliers', 'IQR Outliers', 'Z-Score Outliers (%)', 'IQR Outliers (%)', 'MAD Scores', 'Isolation Forest Outliers', 'LOF Outliers', 'DBSCAN Outliers', 'Skewness', 'Kurtosis'],
#                 'Value': [
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Z-Score Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['IQR Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Z-Score Outliers (%)'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['IQR Outliers (%)'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['MAD Scores'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Isolation Forest Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['LOF Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['DBSCAN Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Skewness'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Kurtosis'].values[0]
#                 ]
#             }
#             summary_df = pd.DataFrame(summary_data)

#             # Save the summary table
#             output_table_path = os.path.join(output_table_dir, f'{feature}_outlier_analysis_summary_{plot_type}.csv')
#             save_dataframe(summary_df, output_table_path)

#             # Create a separate figure for the table
#             fig, ax = plt.subplots(figsize=(12, 2))  # Adjust height to fit the table
#             ax.axis('off')
#             table = ax.table(cellText=summary_df.values, colLabels=summary_df.columns, cellLoc='center', loc='center')
#             table.scale(1, 2)
#             plt.tight_layout()

#             # Save the table as a separate figure
#             output_table_plot_path = os.path.join(output_plot_dir, f'{feature}_outlier_analysis_table_{plot_type}.png')
#             plt.savefig(output_table_plot_path)
#             plt.close(fig)





# # def create_outlier_plots(data, feature, output_plot_dir, plot_type='before'):
# #     fig, ax = plt.subplots(2, 2, figsize=(12, 12))

# #     sns.boxplot(x=data[feature], ax=ax[0, 0])
# #     ax[0, 0].set_title(f"Box Plot of {feature} ({plot_type})")

# #     sns.histplot(data[feature], bins=30, kde=True, ax=ax[0, 1])
# #     ax[0, 1].set_title(f"Histogram of {feature} ({plot_type})")

# #     sns.scatterplot(x=data.index, y=data[feature], ax=ax[1, 0])
# #     ax[1, 0].set_title(f"Scatter Plot of {feature} ({plot_type})")
# #     ax[1, 0].set_xlabel('Index')

# #     sns.violinplot(x=data[feature], ax=ax[1, 1])
# #     ax[1, 1].set_title(f"Violin Plot of {feature} ({plot_type})")

# #     plt.tight_layout()

# #     # Save the combined plot as a figure
# #     output_plot_path = os.path.join(output_plot_dir, f'{feature}_outlier_analysis_{plot_type}.png')
# #     fig.savefig(output_plot_path)
# #     plt.show()  # Display the figure inline
# #     plt.close(fig)

# #     return output_plot_path

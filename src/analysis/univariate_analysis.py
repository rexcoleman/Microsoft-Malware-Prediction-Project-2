# src/analysis/univariate_analysis.py

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os

def plot_histogram(data, feature, ax):
    sns.histplot(data[feature], kde=True, bins=30, ax=ax)
    ax.set_title(f'Distribution of {feature}')
    ax.set_xlabel(feature)
    ax.set_ylabel('Frequency')

def plot_boxplot(data, feature, ax):
    sns.boxplot(y=data[feature], ax=ax)
    ax.set_title(f'Box Plot of {feature}')
    ax.set_ylabel(feature)

def plot_kde(data, feature, ax):
    if pd.api.types.is_numeric_dtype(data[feature]):
        sns.kdeplot(data[feature], fill=True, warn_singular=False, ax=ax)
        ax.set_title(f'Kernel Density Estimate of {feature}')
        ax.set_xlabel(feature)
        ax.set_ylabel('Density')
    else:
        ax.set_title(f'KDE not applicable for {feature}')
        ax.axis('off')

def plot_countplot(data, feature, ax, top_n=10):
    value_counts = data[feature].value_counts().head(top_n)
    sns.barplot(x=value_counts.index, y=value_counts.values, ax=ax)
    ax.set_title(f'Top {top_n} Categories of {feature}')
    ax.set_xlabel(feature)
    ax.set_ylabel('Count')
    ax.set_xticklabels(ax.get_xticklabels(), rotation=45)

def plot_piechart(data, feature, ax, top_n=10):
    value_counts = data[feature].value_counts(normalize=True)
    top_value_counts = value_counts.head(top_n)
    other_percentage = value_counts.iloc[top_n:].sum() * 100  # Use iloc for slicing
    
    labels = list(top_value_counts.index)
    sizes = list(top_value_counts.values * 100)

    if other_percentage > 0:
        labels.append('Other')
        sizes.append(other_percentage)

    ax.pie(sizes, labels=labels, autopct='%1.1f%%')
    ax.set_title(f'Top {top_n} Categories of {feature}')

def plot_binary_feature(data, feature, ax):
    sns.countplot(x=data[feature], ax=ax)
    ax.set_title(f'Count Plot of {feature}')
    ax.set_xlabel(f'{feature} Value')
    ax.set_ylabel('Count')
    total = len(data[feature].dropna())
    for p in ax.patches:
        height = p.get_height()
        ax.text(p.get_x() + p.get_width() / 2., height + 3, '{:1.2f}%'.format(100 * height / total), ha="center")

def determine_feature_type(feature, metadata):
    classified_type = metadata['features'][feature].get('classified_data_type', '')
    if classified_type == 'binary':
        return 'binary'
    if classified_type == 'categorical':
        return 'categorical'
    example_values = metadata['features'][feature].get('example_values', [])
    if all(isinstance(val, (int, float)) for val in example_values):
        if len(example_values) > 0 and isinstance(example_values[0], int):
            return 'categorical'
    return 'numerical'

def create_comparison_table(dataframe, metadata):
    comparison_data = []
    for feature in dataframe.columns:
        classified_type = metadata['features'][feature].get('classified_data_type', 'Unknown')
        determined_type = determine_feature_type(feature, metadata)
        discrepancy = classified_type != determined_type
        comparison_data.append({
            'Feature': feature,
            'Previously Analyzed Type': classified_type,
            'Current Analyzed Type': determined_type,
            'Discrepancy': discrepancy
        })
    comparison_table = pd.DataFrame(comparison_data)
    comparison_table.sort_values(by=['Discrepancy', 'Previously Analyzed Type'], ascending=[False, True], inplace=True)
    return comparison_table

def univariate_analysis(dataframe, output_dir, metadata, comparison_table, unique_value_threshold=20):
    all_features = dataframe.columns
    for feature in all_features:
        feature_type = determine_feature_type(feature, metadata)
        fig, axs = plt.subplots(3, 2, figsize=(18, 24))
        axs = axs.flatten()

        if feature_type == 'categorical' or dataframe[feature].nunique() < unique_value_threshold:
            # Treat as categorical
            plot_countplot(dataframe, feature, axs[0])
            plot_piechart(dataframe, feature, axs[1])
        else:
            # Treat as numerical
            plot_histogram(dataframe, feature, axs[0])
            plot_boxplot(dataframe, feature, axs[1])
            plot_kde(dataframe, feature, axs[2])

        # Always include binary feature plot
        if dataframe[feature].nunique() == 2:
            plot_binary_feature(dataframe, feature, axs[3])

        # Include both categorical and numerical plots for features with numerical values but many unique categories
        if feature_type == 'numerical' and dataframe[feature].nunique() > unique_value_threshold:
            plot_countplot(dataframe, feature, axs[4])
            plot_piechart(dataframe, feature, axs[5])

        plt.tight_layout()
        plt.savefig(f'{output_dir}/{feature}_analysis.png')
        plt.show()

        # Display Summary Statistics or Value Counts
        summary_stats = dataframe[feature].describe()
        print(f"\nSummary Statistics for {feature}:\n{summary_stats}")

        value_counts = dataframe[feature].value_counts(normalize=True).head(10).to_frame(name='Count')
        value_counts['Percentage'] = value_counts['Count'] * 100
        print(f"\nValue Counts for {feature}:\n{value_counts}")

        print("\n--- Contextual Insights and Recommendations ---\n")
        try:
            if feature_type != 'categorical' and dataframe[feature].nunique() >= unique_value_threshold:
                mean = summary_stats.get('mean', 'N/A')
                std = summary_stats.get('std', 'N/A')
                count = summary_stats.get('count', 'N/A')
                min_val = summary_stats.get('min', 'N/A')
                max_val = summary_stats.get('max', 'N/A')
                print(f"High-Level Overview: {feature} has a mean of {mean} and a standard deviation of {std}.")
                print(f"Detailed Technical Insights: The distribution of {feature} shows {count} instances with a range from {min_val} to {max_val}.")
                print("Actionable Recommendations: Use this information to identify potential outliers and decide on normalization or transformation techniques.")
            else:
                unique_categories = len(value_counts)
                most_frequent = value_counts['Count'].idxmax()
                print(f"High-Level Overview: {feature} has {unique_categories} unique categories with the most frequent category being {most_frequent}.")
                print("Detailed Technical Insights: The distribution shows a clear dominance of certain categories which may influence model training.")
                print("Actionable Recommendations: Consider encoding techniques and assess the impact of dominant categories on the target variable.")
        except KeyError as e:
            print(f"An error occurred while processing feature {feature}: {e}")















# src/analysis/univariate_analysis.py

import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import display, HTML
import logging
from typing import Dict, Any, List, Tuple
from src.visualization.plot_utils import create_subplots
from src.visualization.eda import plot_histogram, plot_boxplot, plot_kde, plot_countplot, plot_piechart
from src.utils.metadata_operations import extract_feature_metadata

# Create a CSV for manual review and update
def create_manual_review_csv(metadata: Dict[str, Any], output_path: str) -> None:
    try:
        rows = []
        for feature in sorted(metadata["features"].keys()):
            classified_data_type = metadata["features"][feature]["general_attributes"].get("classified_data_type", "")
            rows.append({"Feature": feature, "Classified_Data_Type": classified_data_type, "Manual_Update_Classified_Data_Type": ""})

        df = pd.DataFrame(rows)
        df.to_csv(output_path, index=False)
        logging.info(f"Manual review CSV created at {output_path}")
    except Exception as e:
        logging.error(f"Error creating manual review CSV: {e}", exc_info=True)
        raise

def calculate_pie_chart_values(dataframe: pd.DataFrame, feature: str, top_n: int = 5) -> Tuple[List[str], List[float]]:
    total_count = len(dataframe[feature])
    missing_count = dataframe[feature].isnull().sum()
    non_missing_data = dataframe[feature].dropna()
    
    top_value_counts = non_missing_data.value_counts().head(top_n)
    remaining_count = non_missing_data.size - top_value_counts.sum()
    
    labels = list(top_value_counts.index) + ['Remaining Values', 'Missing Values']
    sizes = list(top_value_counts.values) + [remaining_count, missing_count]
    
    sizes = [(size / total_count) * 100 for size in sizes]
    
    return labels, sizes

def display_top_values_table(dataframe: pd.DataFrame, feature: str, top_n: int = 5) -> None:
    total_count = len(dataframe[feature])
    value_counts = dataframe[feature].value_counts().head(top_n)
    percentage = (value_counts / total_count) * 100
    
    top_values_df = pd.DataFrame({
        'Value': value_counts.index,
        'Count': value_counts.values,
        'Percentage': percentage.values
    })
    
    missing_row = pd.DataFrame({
        'Value': ['Missing Values'],
        'Count': [dataframe[feature].isnull().sum()],
        'Percentage': [(dataframe[feature].isnull().sum() / total_count) * 100]
    })
    
    top_values_df = pd.concat([top_values_df, missing_row], ignore_index=True)
    
    display(HTML(f"<h3>Top {top_n} Values for {feature}</h3>"))
    display(top_values_df)

def display_metadata_table(feature: str, metadata: Dict[str, Any]) -> None:
    extracted_df = extract_feature_metadata(metadata, feature)
    display(HTML(f"<h3>Technical and Classified Data Types for {feature}</h3>"))
    display(extracted_df)

def generate_grouped_plots(dataframe: pd.DataFrame, feature: str, metadata: Dict[str, Any]) -> None:
    try:
        missing_count = dataframe[feature].isnull().sum()
        total_count = len(dataframe[feature])
        missing_percentage = missing_count / total_count * 100

        fig, axs = create_subplots(3, 2, figsize=(18, 24))
        axs = axs.flatten()

        plot_histogram(dataframe, feature, axs[0])
        plot_boxplot(dataframe, feature, axs[1])
        plot_kde(dataframe, feature, axs[2])
        plot_countplot(dataframe, feature, axs[3])

        labels, sizes = calculate_pie_chart_values(dataframe, feature)
        plot_piechart(labels, sizes, axs[4], feature)

        plt.tight_layout()
        plt.show()

        display_top_values_table(dataframe, feature)
        display_metadata_table(feature, metadata)

        logging.info(f"Grouped plots and metadata table generated for feature: {feature}")

    except Exception as e:
        logging.error(f"Error generating plots for {feature}: {e}", exc_info=True)
        raise



# # src/analysis/univariate_analysis.py

# import pandas as pd
# import matplotlib.pyplot as plt
# from IPython.display import display, HTML
# import logging
# from typing import Dict, Any, List, Tuple
# from src.visualization.plot_utils import create_subplots
# from src.visualization.eda import plot_histogram, plot_boxplot, plot_kde, plot_countplot, plot_piechart
# from src.utils.metadata_operations import extract_feature_metadata

# def calculate_pie_chart_values(dataframe: pd.DataFrame, feature: str, top_n: int = 5) -> Tuple[List[str], List[float]]:
#     total_count = len(dataframe[feature])
#     missing_count = dataframe[feature].isnull().sum()
#     non_missing_data = dataframe[feature].dropna()
    
#     top_value_counts = non_missing_data.value_counts().head(top_n)
#     remaining_count = non_missing_data.size - top_value_counts.sum()
    
#     labels = list(top_value_counts.index) + ['Remaining Values', 'Missing Values']
#     sizes = list(top_value_counts.values) + [remaining_count, missing_count]
    
#     sizes = [(size / total_count) * 100 for size in sizes]
    
#     return labels, sizes

# def display_top_values_table(dataframe: pd.DataFrame, feature: str, top_n: int = 5) -> None:
#     total_count = len(dataframe[feature])
#     value_counts = dataframe[feature].value_counts().head(top_n)
#     percentage = (value_counts / total_count) * 100
    
#     top_values_df = pd.DataFrame({
#         'Value': value_counts.index,
#         'Count': value_counts.values,
#         'Percentage': percentage.values
#     })
    
#     missing_row = pd.DataFrame({
#         'Value': ['Missing Values'],
#         'Count': [dataframe[feature].isnull().sum()],
#         'Percentage': [(dataframe[feature].isnull().sum() / total_count) * 100]
#     })
    
#     top_values_df = pd.concat([top_values_df, missing_row], ignore_index=True)
    
#     display(HTML(f"<h3>Top {top_n} Values for {feature}</h3>"))
#     display(top_values_df)

# def display_metadata_table(feature: str, metadata: Dict[str, Any]) -> None:
#     extracted_df = extract_feature_metadata(metadata, feature)
#     display(HTML(f"<h3>Technical and Classified Data Types for {feature}</h3>"))
#     display(extracted_df)

# def generate_grouped_plots(dataframe: pd.DataFrame, feature: str, metadata: Dict[str, Any]) -> None:
#     try:
#         missing_count = dataframe[feature].isnull().sum()
#         total_count = len(dataframe[feature])
#         missing_percentage = missing_count / total_count * 100

#         fig, axs = create_subplots(3, 2, figsize=(18, 24))
#         axs = axs.flatten()

#         plot_histogram(dataframe, feature, axs[0])
#         plot_boxplot(dataframe, feature, axs[1])
#         plot_kde(dataframe, feature, axs[2])
#         plot_countplot(dataframe, feature, axs[3])

#         labels, sizes = calculate_pie_chart_values(dataframe, feature)
#         plot_piechart(labels, sizes, axs[4], feature)

#         plt.tight_layout()
#         plt.show()

#         display_top_values_table(dataframe, feature)
#         display_metadata_table(feature, metadata)

#         logging.info(f"Grouped plots and metadata table generated for feature: {feature}")

#     except Exception as e:
#         logging.error(f"Error generating plots for {feature}: {e}", exc_info=True)
#         raise







# # # src/analysis/univariate_analysis.py

# # import pandas as pd
# # import matplotlib.pyplot as plt
# # from IPython.display import display, HTML
# # import logging
# # from typing import Dict, Any, List, Tuple
# # from src.visualization.plot_utils import create_subplots
# # from src.visualization.eda import plot_histogram, plot_boxplot, plot_kde, plot_countplot, plot_piechart
# # from src.utils.metadata_operations import extract_feature_metadata

# # def calculate_pie_chart_values(dataframe: pd.DataFrame, feature: str, top_n: int = 5) -> Tuple[List[str], List[float]]:
# #     total_count = len(dataframe[feature])
# #     missing_count = dataframe[feature].isnull().sum()
# #     non_missing_data = dataframe[feature].dropna()
    
# #     top_value_counts = non_missing_data.value_counts().head(top_n)
# #     remaining_count = non_missing_data.size - top_value_counts.sum()
    
# #     labels = list(top_value_counts.index) + ['Remaining Values', 'Missing Values']
# #     sizes = list(top_value_counts.values) + [remaining_count, missing_count]
    
# #     sizes = [(size / total_count) * 100 for size in sizes]
    
# #     return labels, sizes

# # def display_top_values_table(dataframe: pd.DataFrame, feature: str, top_n: int = 5) -> None:
# #     total_count = len(dataframe[feature])
# #     value_counts = dataframe[feature].value_counts().head(top_n)
# #     percentage = (value_counts / total_count) * 100
    
# #     top_values_df = pd.DataFrame({
# #         'Value': value_counts.index,
# #         'Count': value_counts.values,
# #         'Percentage': percentage.values
# #     })
    
# #     missing_row = pd.DataFrame({
# #         'Value': ['Missing Values'],
# #         'Count': [dataframe[feature].isnull().sum()],
# #         'Percentage': [(dataframe[feature].isnull().sum() / total_count) * 100]
# #     })
    
# #     top_values_df = pd.concat([top_values_df, missing_row], ignore_index=True)
    
# #     display(HTML(f"<h3>Top {top_n} Values for {feature}</h3>"))
# #     display(top_values_df)

# # def display_metadata_table(feature: str, metadata: Dict[str, Any]) -> None:
# #     extracted_df = extract_feature_metadata(metadata, feature)
# #     display(HTML(f"<h3>Technical and Classified Data Types for {feature}</h3>"))
# #     display(extracted_df)

# # def generate_grouped_plots(dataframe: pd.DataFrame, feature: str, metadata: Dict[str, Any]) -> None:
# #     try:
# #         missing_count = dataframe[feature].isnull().sum()
# #         total_count = len(dataframe[feature])
# #         missing_percentage = missing_count / total_count * 100

# #         fig, axs = create_subplots(3, 2, figsize=(18, 24))
# #         axs = axs.flatten()

# #         plot_histogram(dataframe, feature, axs[0])
# #         plot_boxplot(dataframe, feature, axs[1])
# #         plot_kde(dataframe, feature, axs[2])
# #         plot_countplot(dataframe, feature, axs[3])

# #         labels, sizes = calculate_pie_chart_values(dataframe, feature)
# #         plot_piechart(labels, sizes, axs[4], feature)

# #         plt.tight_layout()
# #         plt.show()

# #         display_top_values_table(dataframe, feature)
# #         display_metadata_table(feature, metadata)

# #         logging.info(f"Grouped plots and metadata table generated for feature: {feature}")

# #     except Exception as e:
# #         logging.error(f"Error generating plots for {feature}: {e}", exc_info=True)
# #         raise

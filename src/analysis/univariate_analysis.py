# src/analysis/univariate_analysis.py

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os

def plot_histogram(data, feature, ax):
    sns.histplot(data[feature], kde=True, bins=30, ax=ax)
    ax.set_title(f'Distribution of {feature}')
    ax.set_xlabel(feature)
    ax.set_ylabel('Frequency')

def plot_boxplot(data, feature, ax):
    sns.boxplot(y=data[feature], ax=ax)
    ax.set_title(f'Box Plot of {feature}')
    ax.set_ylabel(feature)

def plot_kde(data, feature, ax):
    if pd.api.types.is_numeric_dtype(data[feature]):
        sns.kdeplot(data[feature], fill=True, warn_singular=False, ax=ax)
        ax.set_title(f'Kernel Density Estimate of {feature}')
        ax.set_xlabel(feature)
        ax.set_ylabel('Density')
    else:
        ax.set_title(f'KDE not applicable for {feature}')
        ax.axis('off')

def plot_countplot(data, feature, ax):
    sns.countplot(x=data[feature], order=data[feature].value_counts().index, ax=ax)
    ax.set_title(f'Distribution of {feature}')
    ax.set_xlabel(feature)
    ax.set_ylabel('Count')
    ax.set_xticklabels(ax.get_xticklabels(), rotation=45)

def plot_piechart(data, feature, ax):
    data[feature].value_counts().plot.pie(autopct='%1.1f%%', ax=ax)
    ax.set_title(f'Pie Chart of {feature}')
    ax.set_ylabel('')

def plot_binary_feature(data, feature, ax):
    sns.countplot(x=data[feature], ax=ax)
    ax.set_title(f'Count Plot of {feature}')
    ax.set_xlabel(f'{feature} Value')
    ax.set_ylabel('Count')
    total = len(data[feature].dropna())
    for p in ax.patches:
        height = p.get_height()
        ax.text(p.get_x() + p.get_width() / 2., height + 3, '{:1.2f}%'.format(100 * height / total), ha="center")

def determine_feature_type(feature, metadata):
    # Determine the feature type using metadata
    example_values = metadata['features'][feature].get('example_values', [])
    if all(isinstance(val, (int, float)) for val in example_values):
        if len(example_values) > 0 and isinstance(example_values[0], int):
            return 'categorical'
    return 'numerical'

def univariate_analysis(dataframe, output_dir, metadata, unique_value_threshold=20):
    all_features = dataframe.columns
    for feature in all_features:
        feature_type = determine_feature_type(feature, metadata)
        fig, axs = plt.subplots(3, 2, figsize=(15, 18))
        axs = axs.flatten()

        if feature_type == 'categorical' or dataframe[feature].nunique() < unique_value_threshold:
            # Treat as categorical
            plot_countplot(dataframe, feature, axs[0])
            plot_piechart(dataframe, feature, axs[1])
        else:
            # Treat as numerical
            plot_histogram(dataframe, feature, axs[0])
            plot_boxplot(dataframe, feature, axs[1])
            plot_kde(dataframe, feature, axs[2])

        # Always include binary feature plot
        if dataframe[feature].nunique() == 2:
            plot_binary_feature(dataframe, feature, axs[3])

        # Include both categorical and numerical plots for features with numerical values but many unique categories
        if feature_type == 'numerical' and dataframe[feature].nunique() > unique_value_threshold:
            plot_countplot(dataframe, feature, axs[4])
            plot_piechart(dataframe, feature, axs[5])

        plt.tight_layout()
        plt.savefig(f'{output_dir}/{feature}_analysis.png')
        plt.show()

        # Display Summary Statistics or Value Counts
        summary_stats = dataframe[feature].describe()
        print(f"\nSummary Statistics for {feature}:\n{summary_stats}")

        value_counts = dataframe[feature].value_counts().head(10)
        print(f"\nValue Counts for {feature}:\n{value_counts}")

        print("\n--- Contextual Insights and Recommendations ---\n")
        try:
            if feature_type != 'categorical' and dataframe[feature].nunique() >= unique_value_threshold:
                mean = summary_stats.get('mean', 'N/A')
                std = summary_stats.get('std', 'N/A')
                count = summary_stats.get('count', 'N/A')
                min_val = summary_stats.get('min', 'N/A')
                max_val = summary_stats.get('max', 'N/A')
                print(f"High-Level Overview: {feature} has a mean of {mean} and a standard deviation of {std}.")
                print(f"Detailed Technical Insights: The distribution of {feature} shows {count} instances with a range from {min_val} to {max_val}.")
                print("Actionable Recommendations: Use this information to identify potential outliers and decide on normalization or transformation techniques.")
            else:
                unique_categories = len(value_counts)
                most_frequent = value_counts.idxmax()
                print(f"High-Level Overview: {feature} has {unique_categories} unique categories with the most frequent category being {most_frequent}.")
                print("Detailed Technical Insights: The distribution shows a clear dominance of certain categories which may influence model training.")
                print("Actionable Recommendations: Consider encoding techniques and assess the impact of dominant categories on the target variable.")
        except KeyError as e:
            print(f"An error occurred while processing feature {feature}: {e}")



# # src/analysis/univariate_analysis.py

# import pandas as pd
# import matplotlib.pyplot as plt
# import seaborn as sns
# import os

# def plot_histogram(data, feature, ax):
#     sns.histplot(data[feature], kde=True, bins=30, ax=ax)
#     ax.set_title(f'Distribution of {feature}')
#     ax.set_xlabel(feature)
#     ax.set_ylabel('Frequency')

# def plot_boxplot(data, feature, ax):
#     sns.boxplot(y=data[feature], ax=ax)
#     ax.set_title(f'Box Plot of {feature}')
#     ax.set_ylabel(feature)

# def plot_kde(data, feature, ax):
#     if pd.api.types.is_numeric_dtype(data[feature]):
#         sns.kdeplot(data[feature], fill=True, warn_singular=False, ax=ax)
#         ax.set_title(f'Kernel Density Estimate of {feature}')
#         ax.set_xlabel(feature)
#         ax.set_ylabel('Density')
#     else:
#         ax.set_title(f'KDE not applicable for {feature}')
#         ax.axis('off')

# def plot_countplot(data, feature, ax):
#     sns.countplot(x=data[feature], order=data[feature].value_counts().index, ax=ax)
#     ax.set_title(f'Distribution of {feature}')
#     ax.set_xlabel(feature)
#     ax.set_ylabel('Count')
#     ax.set_xticklabels(ax.get_xticklabels(), rotation=45)

# def plot_piechart(data, feature, ax):
#     data[feature].value_counts().plot.pie(autopct='%1.1f%%', ax=ax)
#     ax.set_title(f'Pie Chart of {feature}')
#     ax.set_ylabel('')

# def plot_binary_feature(data, feature, ax):
#     sns.countplot(x=data[feature], ax=ax)
#     ax.set_title(f'Count Plot of {feature}')
#     ax.set_xlabel(f'{feature} Value')
#     ax.set_ylabel('Count')
#     total = len(data[feature].dropna())
#     for p in ax.patches:
#         height = p.get_height()
#         ax.text(p.get_x() + p.get_width() / 2., height + 3, '{:1.2f}%'.format(100 * height / total), ha="center")

# def determine_feature_type(feature, metadata):
#     # Determine the feature type using metadata
#     example_values = metadata['features'][feature].get('example_values', [])
#     if all(isinstance(val, (int, float)) for val in example_values):
#         if len(example_values) > 0 and isinstance(example_values[0], int):
#             return 'categorical'
#     return 'numerical'

# def univariate_analysis(dataframe, output_dir, metadata, unique_value_threshold=20):
#     all_features = dataframe.columns
#     for feature in all_features:
#         feature_type = determine_feature_type(feature, metadata)
#         fig, axs = plt.subplots(3, 2, figsize=(15, 18))
#         axs = axs.flatten()

#         if feature_type == 'categorical' or dataframe[feature].nunique() < unique_value_threshold:
#             # Treat as categorical
#             plot_countplot(dataframe, feature, axs[0])
#             plot_piechart(dataframe, feature, axs[1])
#         else:
#             # Treat as numerical
#             plot_histogram(dataframe, feature, axs[0])
#             plot_boxplot(dataframe, feature, axs[1])
#             plot_kde(dataframe, feature, axs[2])

#         # Always include binary feature plot
#         if dataframe[feature].nunique() == 2:
#             plot_binary_feature(dataframe, feature, axs[3])

#         # Additionally, include categorical plots for features with numerical values but many unique categories
#         if feature_type == 'numerical' and dataframe[feature].nunique() > unique_value_threshold:
#             plot_countplot(dataframe, feature, axs[4])
#             plot_piechart(dataframe, feature, axs[5])

#         plt.tight_layout()
#         plt.savefig(f'{output_dir}/{feature}_analysis.png')
#         plt.show()

#         # Display Summary Statistics or Value Counts
#         summary_stats = dataframe[feature].describe()
#         print(f"\nSummary Statistics for {feature}:\n{summary_stats}")

#         value_counts = dataframe[feature].value_counts().head(10)
#         print(f"\nValue Counts for {feature}:\n{value_counts}")

#         print("\n--- Contextual Insights and Recommendations ---\n")
#         try:
#             if feature_type != 'categorical' and dataframe[feature].nunique() >= unique_value_threshold:
#                 mean = summary_stats.get('mean', 'N/A')
#                 std = summary_stats.get('std', 'N/A')
#                 count = summary_stats.get('count', 'N/A')
#                 min_val = summary_stats.get('min', 'N/A')
#                 max_val = summary_stats.get('max', 'N/A')
#                 print(f"High-Level Overview: {feature} has a mean of {mean} and a standard deviation of {std}.")
#                 print(f"Detailed Technical Insights: The distribution of {feature} shows {count} instances with a range from {min_val} to {max_val}.")
#                 print("Actionable Recommendations: Use this information to identify potential outliers and decide on normalization or transformation techniques.")
#             else:
#                 unique_categories = len(value_counts)
#                 most_frequent = value_counts.idxmax()
#                 print(f"High-Level Overview: {feature} has {unique_categories} unique categories with the most frequent category being {most_frequent}.")
#                 print("Detailed Technical Insights: The distribution shows a clear dominance of certain categories which may influence model training.")
#                 print("Actionable Recommendations: Consider encoding techniques and assess the impact of dominant categories on the target variable.")
#         except KeyError as e:
#             print(f"An error occurred while processing feature {feature}: {e}")




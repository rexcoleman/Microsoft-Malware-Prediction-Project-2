# # src/utils/data_processing.py

# import os
# import pandas as pd
# import matplotlib.pyplot as plt
# import seaborn as sns
# from tqdm.notebook import tqdm
# from scipy.stats import zscore, skew, kurtosis
# from sklearn.ensemble import IsolationForest
# from sklearn.neighbors import LocalOutlierFactor
# from sklearn.cluster import DBSCAN
# import numpy as np
# from src.utils.common import save_dataframe, save_json_file

# def read_csv_with_progress(file_path, chunksize=10000):
#     total_lines = sum(1 for _ in open(file_path)) - 1  # Calculate total lines in the file
#     chunk_list = []
#     for chunk in tqdm(pd.read_csv(file_path, chunksize=chunksize, low_memory=False), total=total_lines//chunksize + 1, desc="Loading data"):
#         chunk_list.append(chunk)
#     return pd.concat(chunk_list, axis=0)

# def calculate_outlier_metrics(data):
#     outlier_metrics = []

#     for feature in tqdm(data.columns, desc="Processing features"):
#         if data[feature].dtype in ['float64', 'int64']:
#             feature_data = data[feature].dropna()
#             if feature_data.empty:
#                 continue

#             # Z-Score Outliers
#             z_scores = zscore(feature_data)
#             z_outliers = (z_scores > 3) | (z_scores < -3)

#             # IQR Outliers
#             iqr = feature_data.quantile(0.75) - feature_data.quantile(0.25)
#             lower_bound = feature_data.quantile(0.25) - 1.5 * iqr
#             upper_bound = feature_data.quantile(0.75) + 1.5 * iqr
#             iqr_outliers = (feature_data < lower_bound) | (feature_data > upper_bound)

#             # MAD Scores
#             median = feature_data.median()
#             mad = np.median(np.abs(feature_data - median))
#             mad_scores = np.abs(feature_data - median) / mad

#             # Isolation Forest Outliers
#             isolation_forest = IsolationForest(contamination=0.05)
#             isolation_forest.fit(feature_data.values.reshape(-1, 1))
#             iso_outliers = isolation_forest.predict(feature_data.values.reshape(-1, 1)) == -1

#             # LOF Outliers
#             lof = LocalOutlierFactor(n_neighbors=20, contamination=0.05)
#             lof_outliers = lof.fit_predict(feature_data.values.reshape(-1, 1)) == -1

#             # DBSCAN Outliers
#             dbscan = DBSCAN(eps=0.5, min_samples=5)
#             dbscan_outliers = dbscan.fit_predict(feature_data.values.reshape(-1, 1)) == -1

#             # Skewness and Kurtosis
#             skewness = skew(feature_data)
#             kurtosis_value = kurtosis(feature_data)

#             metrics = {
#                 'Feature': feature,
#                 'Z-Score Outliers': z_outliers.sum(),
#                 'IQR Outliers': iqr_outliers.sum(),
#                 'Z-Score Outliers (%)': z_outliers.mean() * 100,
#                 'IQR Outliers (%)': iqr_outliers.mean() * 100,
#                 'MAD Scores': (mad_scores > 3).sum(),
#                 'Isolation Forest Outliers': iso_outliers.sum(),
#                 'LOF Outliers': lof_outliers.sum(),
#                 'DBSCAN Outliers': dbscan_outliers.sum(),
#                 'Skewness': skewness,
#                 'Kurtosis': kurtosis_value
#             }
#             outlier_metrics.append(metrics)

#     return pd.DataFrame(outlier_metrics)

# def save_outlier_metrics(outlier_metrics_df, path):
#     if not outlier_metrics_df.empty:
#         save_json_file(outlier_metrics_df.to_dict(orient='records'), path)

# def create_outlier_plots(data, feature, output_plot_dir, plot_type='before'):
#     fig, ax = plt.subplots(2, 2, figsize=(12, 12))

#     sns.boxplot(x=data[feature], ax=ax[0, 0])
#     ax[0, 0].set_title(f"Box Plot of {feature} ({plot_type})")

#     sns.histplot(data[feature], bins=30, kde=True, ax=ax[0, 1])
#     ax[0, 1].set_title(f"Histogram of {feature} ({plot_type})")

#     sns.scatterplot(x=data.index, y=data[feature], ax=ax[1, 0])
#     ax[1, 0].set_title(f"Scatter Plot of {feature} ({plot_type})")
#     ax[1, 0].set_xlabel('Index')

#     sns.violinplot(x=data[feature], ax=ax[1, 1])
#     ax[1, 1].set_title(f"Violin Plot of {feature} ({plot_type})")

#     plt.tight_layout()

#     # Save the combined plot as a figure
#     output_plot_path = os.path.join(output_plot_dir, f'{feature}_outlier_analysis_{plot_type}.png')
#     fig.savefig(output_plot_path)
#     plt.show()  # Display the figure inline
#     plt.close(fig)

#     return output_plot_path

# def orchestrate_outlier_plots(data, outlier_metrics_df, output_plot_dir, output_table_dir, plot_type='before'):
#     for feature in tqdm(data.columns, desc=f"Creating {plot_type} plots"):
#         if data[feature].dtype in ['float64', 'int64']:
#             output_plot_path = create_outlier_plots(data, feature, output_plot_dir, plot_type)

#             # Create a summary table
#             summary_data = {
#                 'Metric': ['Z-Score Outliers', 'IQR Outliers', 'Z-Score Outliers (%)', 'IQR Outliers (%)', 'MAD Scores', 'Isolation Forest Outliers', 'LOF Outliers', 'DBSCAN Outliers', 'Skewness', 'Kurtosis'],
#                 'Value': [
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Z-Score Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['IQR Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Z-Score Outliers (%)'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['IQR Outliers (%)'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['MAD Scores'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Isolation Forest Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['LOF Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['DBSCAN Outliers'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Skewness'].values[0],
#                     outlier_metrics_df[outlier_metrics_df['Feature'] == feature]['Kurtosis'].values[0]
#                 ]
#             }
#             summary_df = pd.DataFrame(summary_data)

#             # Save the summary table
#             output_table_path = os.path.join(output_table_dir, f'{feature}_outlier_analysis_summary_{plot_type}.csv')
#             save_dataframe(summary_df, output_table_path)

#             # Create a separate figure for the table
#             fig, ax = plt.subplots(figsize=(12, 2))  # Adjust height to fit the table
#             ax.axis('off')
#             table = ax.table(cellText=summary_df.values, colLabels=summary_df.columns, cellLoc='center', loc='center')
#             table.scale(1, 2)
#             plt.tight_layout()

#             # Save the table as a separate figure
#             output_table_plot_path = os.path.join(output_plot_dir, f'{feature}_outlier_analysis_table_{plot_type}.png')
#             plt.savefig(output_table_plot_path)
#             plt.show()  # Display the table inline
#             plt.close(fig)

#             # Display plots and table inline in notebook
#             from IPython.display import Image, display
#             display(Image(filename=output_plot_path))
#             display(summary_df)
#             display(Image(filename=output_table_plot_path))

# # src/utils/data_processing.py

# import pandas as pd

# def calculate_summary_statistics(df, feature):
#     return {
#         'mean': df[feature].mean(),
#         'std': df[feature].std(),
#         'skewness': df[feature].skew(),
#         'kurtosis': df[feature].kurtosis()
#     }

# def format_statistics(statistics):
#     formatted = {}
#     for key, value in statistics.items():
#         formatted[key] = f"{value:.2e}"
#     return formatted



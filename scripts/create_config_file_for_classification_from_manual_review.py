# scripts/create_config_file_for_classification_from_manual_review.py

import os
import sys
import pandas as pd
import logging
from typing import Dict, Any

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def find_project_root(marker_file: str = 'src/config_loader.py') -> str:
    current_dir = os.getcwd()
    while current_dir != os.path.dirname(current_dir):
        if os.path.isfile(os.path.join(current_dir, marker_file)):
            return current_dir
        current_dir = os.path.dirname(current_dir)
    raise FileNotFoundError(f"Marker file '{marker_file}' not found in any parent directories.")

def set_project_root() -> str:
    project_root = find_project_root()
    os.chdir(project_root)
    if project_root not in sys.path:
        sys.path.append(project_root)
    logging.info(f"Project root set to: {project_root}")
    return project_root

# Find and set the project root directory
project_root = set_project_root()

# Import setup function from custom module
from src.utils.environment_setup import setup_project_environment
from src.utils.json_pipeline import save_json_with_pipeline

# Set up the project environment
paths, directories = setup_project_environment()

def load_manual_review_csv(csv_path: str) -> pd.DataFrame:
    """
    Load the CSV file containing manual updates for feature classification.

    Parameters:
    csv_path (str): The path to the CSV file.

    Returns:
    pd.DataFrame: The loaded CSV file as a DataFrame.
    """
    try:
        return pd.read_csv(csv_path)
    except Exception as e:
        logging.error(f"Error loading manual review CSV: {e}", exc_info=True)
        raise

def create_classification_update_config(manual_review_df: pd.DataFrame) -> Dict[str, Any]:
    """
    Create a configuration dictionary based on the manual review DataFrame.

    Parameters:
    manual_review_df (pd.DataFrame): DataFrame containing the manual updates.

    Returns:
    Dict[str, Any]: The configuration dictionary structured according to the schema.
    """
    config = {"features": {}}
    for _, row in manual_review_df.iterrows():
        feature = row["Feature"]
        manual_update_classified_data_type = row["Manual_Update_Classified_Data_Type"]
        
        if manual_update_classified_data_type:  # Only include rows where manual update is provided
            config["features"][feature] = {
                "general_attributes": {
                    "classified_data_type": manual_update_classified_data_type
                }
            }
    return config

def save_classification_update_config(config: Dict[str, Any], output_path: str) -> None:
    """
    Save the configuration to a JSON file using the custom pipeline.

    Parameters:
    config (Dict[str, Any]): The configuration dictionary to save.
    output_path (str): The path where the JSON file will be saved.
    """
    try:
        save_json_with_pipeline(config, output_path)
        logging.info(f"Classification update config saved to {output_path}")
    except Exception as e:
        logging.error(f"Error saving classification update config: {e}", exc_info=True)
        raise

def main(paths: Dict[str, Any]) -> None:
    """
    Main function to create and save the feature classification update configuration.
    """
    try:
        csv_path = os.path.join(paths['reports']['manual_review_and_update'], 'feature_classification_manual_review_and_update.csv')
        
        # Extract the directory for config and append the filename
        output_json_path = os.path.join(paths['config']['manual_feature_classification_update'], 'manual_feature_classification_update.json')
        
        # Load manual review CSV
        manual_review_df = load_manual_review_csv(csv_path)
        
        # Create configuration dictionary
        config = create_classification_update_config(manual_review_df)
        
        # Save the configuration JSON file
        save_classification_update_config(config, output_json_path)

        logging.info("Manual classification update config file created successfully.")
    
    except Exception as e:
        logging.error(f"Error in main function: {e}", exc_info=True)

# Execute the main function with the provided paths
main(paths)
